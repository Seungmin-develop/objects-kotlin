# 2장 객체지향 프로그래밍
## 요구사항 정리

-  '영화' => 영화에 대한 기본 정보(제목, 상영시간, 가격 정보 등)
- '상영' => 실제로 관객들이 영화를 관람하는 사건
- 할인 조건 => 가격의 할인 여부를 결정, '순서 조건'과 '기간 조건'으로 구분
- 할인 정책 => 할인 요금을 결정, '금액 할인 정책'과 '비율 할인 정책'으로 구분
- 영화별로 하나의 할인 정책, 다수의 할인 조건 할당 가능

## 협력, 객체, 클래스
진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야 한다. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

## 도메인의 구조를 따르는 프로그램 구조
문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.

## 클래스 구현하기
클래스를 구현할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 클래스는 내부와 외부로 구분되며
훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것이다.

클래스의 내부와 외부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하고 프로그래머에게 구현의 자유를 제공하기 때문이다.
객체는 **상태(state)** 와 **행동(behavior)** 을 함께 가지는 복합적인 존재이고 스스로 판단하고 행동하는 자율적인 존재이다.

데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화**라고 부른다.
객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서이다. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는
자율적인 객체들의 공동체를 구성하는 것이다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이스(public interface)** 라고 부른다. 다른 하나는
외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현(implementation)** 이라고 부른다.

## 프로그래머의 자유
프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 구분하는 것이 유용하다.
클래스 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.
**구현 은닉(implementation hiding)** 은 클래스 작성자가 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지를 숨기는데, 숨겨 놓은 부분에 마음대로
접근할 수 없도록 방지하고 내부 구현을 마음대로 변경할 수 있도록 하는 것을 말한다.

객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면
그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것이 전체적인 설계의 명확성과 유연성을 높일 수 있다.

## 협력에 관한 짧은 이야기
객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청(request)** 할 수 있다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)** 한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)** 하는 것 뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)** 했다고 이야기 한다.
수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 부른다.

부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 **TEMPLATE METHOD 패턴**이라고 부른다.

오바리이딩은 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 가리킨다. 오버로딩은 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다.
오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 이 메서드들은 사이 좋게 공존한다.

## 컴파일 시간 의존성과 실행 시간 의존성
코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 유연하게, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.
다만 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다.

의존하고 있는 객체의 정확한 타입을 알기 위해서는 의존성을 연결하는 부분을 찾아봐야 한다. 따라서 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.

## 상속과 인터페이스
인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다. 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있게되므로
외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다. 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다.

## 다형성
실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는데 이를 다형성이라고 부른다. 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.
다형성을 구현하는 방법은 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 런타임 시점에 결정한다는 공통점이 있으며, 이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 한다.

## 상속
상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만 캡슐화를 위반한다는 것, 설계를 유연하지 못하게 만든다는 점에서 설계에 안좋은 영향을 끼친다. 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

## 합성
인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다. 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 인터페이스를 통해 약하게 결합된다는 특징이 있다. 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 따라서 코드 재사용을 위해서는 상속보다는 합성을 선호한다. 그렇다고 상속을 사용하지 말라는 것이 아니다. 
코드를 재사용하는 경우에는 합성을 더 선호, 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다.